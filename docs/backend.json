{
  "entities": {
    "MediaItem": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MediaItem",
      "type": "object",
      "description": "Represents a movie or TV show in the user's library.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the media item."
        },
        "title": {
          "type": "string",
          "description": "The title of the media item."
        },
        "year": {
          "type": "number",
          "description": "The release year of the media item.",
          "format": "number"
        },
        "filePath": {
          "type": "string",
          "description": "The file path to the media item on disk."
        },
        "apiId": {
          "type": "string",
          "description": "The ID of the media item from the external API (e.g., TMDB)."
        },
        "watched": {
          "type": "boolean",
          "description": "Indicates whether the user has watched the media item."
        },
        "owned": {
          "type": "boolean",
          "description": "Indicates whether the user owns the media item on disk."
        },
        "synopsis": {
          "type": "string",
          "description": "Short synopsis of the movie generated by AI."
        },
        "tagIds": {
          "type": "array",
          "description": "References to Tags. (Relationship: Tag N:N MediaItem)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "title",
        "filePath"
      ]
    },
    "Tag": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tag",
      "type": "object",
      "description": "Represents a custom tag that can be applied to media items.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the tag."
        },
        "name": {
          "type": "string",
          "description": "The name of the tag."
        }
      },
      "required": [
        "id",
        "name"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}/mediaItems/{mediaItemId}",
        "definition": {
          "entityName": "MediaItem",
          "schema": {
            "$ref": "#/backend/entities/MediaItem"
          },
          "description": "Stores media items owned by a specific user. Includes denormalized userId for authorization independence. This path structure allows for path-based ownership, making security rules simple and efficient.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "mediaItemId",
              "description": "The unique identifier of the media item."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/tags/{tagId}",
        "definition": {
          "entityName": "Tag",
          "schema": {
            "$ref": "#/backend/entities/Tag"
          },
          "description": "Stores tags created by a specific user. Includes denormalized userId for authorization independence.  This path structure allows for path-based ownership, making security rules simple and efficient.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "tagId",
              "description": "The unique identifier of the tag."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to store media items and tags for a personal media library application. It follows the principle of Authorization Independence by storing user-owned data under the `/users/{userId}` path. This allows for simple and secure rules based on `request.auth.uid`. The structure also facilitates secure list operations (QAPs) by segregating user data, preventing unauthorized access to other users' media libraries. The `tags` subcollection allows each user to define their own set of tags associated with their media library. Explicit state modeling is achieved through the `watched` and `owned` boolean fields. The design prioritizes a predictable schema by using static keys and avoiding dynamic keys. Denormalization isn't needed because there is no collaborative data. Instead, ownership is implied through the user id."
  }
}